# Демьяненко Виктор Николаевич БПИ217
## Домашнее задание по ОС #3
## Вариант 29

## Цель и задачи: 
Изучить работу с транспортным протоколом TCP. Научиться разбивать задачу  на части, для последующего их выполнения серверами и клиентами.

## Условие задачи:

Первая военная задача. Темной–темной ночью прапорщики Иванов, Петров и Нечепорук занимаются хищением военного имущества со склада родной военной части. Будучи умными людьми и
отличниками боевой и строевой подготовки, прапорщики ввели разделение труда. Иванов выносит имущество со склада и передает его
в руки Петрову, который грузит его в грузовик. Нечепорук стоит на
шухере и заодно подсчитывает рыночную стоимость добычи поле
погрузки в грузовик очередной партии похищенного. Требуется
создать приложение, моделирующее деятельность прапорщиков. Время выполнения каждого действия прапорщиков–
процессов задавать случайным образом.

## Выполненное условие:

- 4 балла ✓
- 5 балла ✓
- 6 балла ✓
- 7 балла ✓
- 8 балла ✓

## Сценарий задачи:

Для решения данной задачи клиент-серверного взаимодействия между прапорщиками Ивановым, Петровым и Нечепоруком, мы можем использовать схему "один сервер - множество клиентов". Сервер будет отвечать за координацию действий и хранение общих данных, а каждый клиент (прапорщик) будет выполнять свою задачу в отдельном процессе. Также в этот раз изменил я изменил имена прапорщиков на "Вор".

## Схема решения 

1. Сервер запускается и создает необходимые для работы ресурсы, такие как разделяемая память и семафоры.
2. Клиенты (прапорщики) запускаются и подключаются к серверу.
3. Каждый клиент случайным образом определяет время выполнения своих действий, например, время выноса имущества со склада и загрузки его в грузовик.
4. Клиенты отправляют запросы серверу для получения доступа к общим ресурсам (например, семафорам) перед выполнением своих действий.
5. Сервер обрабатывает запросы клиентов и контролирует доступ к общим ресурсам, чтобы обеспечить взаимоисключение и согласованность операций.
6. Клиенты выполняют свои действия (выносят имущество со склада, загружают его в грузовик) и отправляют обновленные данные серверуx`.
7. Сервер получает обновленные данные от клиентов и может выполнять дополнительную обработку, например, подсчет рыночной стоимости добычи.
8. Процесс повторяется до достижения заданного условия завершения (например, заданное количество циклов выполнения действий).

Каждый процесс клиента (прапорщика) будет выполнять следующие шаги:

1. Подключение к серверу.
2. Генерация случайного времени выполнения действий.
3. Цикл действий, включающий:
- Ожидание разрешения доступа к общим ресурсам, отправка запроса серверу.
- Выполнение действий (вынос имущества, загрузка в грузовик).
- Обновление данных и отправка их серверу.
- Ожидание разрешения доступа к общим ресурсам после выполнения действий.
4. Отключение от сервера и завершение процесса клиента.

## Завершение программы и удаление ресурсов

- Программа будет завершаться, когда все процессы прапорщиков успешно выполнят свои действия или при прерывании с клавиатуры по соответствующему сигналу (например, Ctrl+C). При завершении программы будет предусмотрено корректное удаление разделяемой памяти и семафоров.
- Разделяемая память и семафоры будут корректно удалены при завершении программы или при обработке сигнала прерывания с клавиатуры. Это будет выполнено с использованием функций удаления разделяемой памяти и семафоров.


## Код сервера на языке С:

```C
// Код сервера

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <time.h>

// Ключи для разделяемой памяти и семафора
#define SHM_KEY 1234
#define SEM_KEY 5678

// Структура для хранения похищенного имущества
typedef struct
{
    int items;
    int value;
} StolenGoods;

// Функция для ожидания освобождения семафора
void sem_wait(int sem_id)
{
    struct sembuf sem_op = {0, -1, 0};
    semop(sem_id, &sem_op, 1);
}

// Функция для освобождения семафора
void sem_post(int sem_id)
{
    struct sembuf sem_op = {0, 1, 0};
    semop(sem_id, &sem_op, 1);
}

int main()
{
    // Создание ключей для разделяемой памяти и семафора
    int shm_id = shmget(SHM_KEY, sizeof(StolenGoods), IPC_CREAT | 0666);
    if (shm_id == -1)
    {
        perror("Ошибка создания разделяемой памяти");
        exit(EXIT_FAILURE);
    }
    int sem_id = semget(SEM_KEY, 1, IPC_CREAT | 0666); 
    if (sem_id == -1)
    {
        perror("Ошибка создания/получения семафора");
        exit(EXIT_FAILURE);
    }

    // Инициализация генератора случайных чисел
    srand(time(NULL));

    // Инициализация разделяемой памяти
    StolenGoods *stolen_goods = (StolenGoods *)shmat(shm_id, NULL, 0);
    if (stolen_goods == (void *)-1)
    {
        perror("Ошибка отображения разделяемой памяти");
        exit(EXIT_FAILURE);
    }

    stolen_goods->items = 0;
    stolen_goods->value = 0;

    // Инициализация семафора
    semctl(sem_id, 0, SETVAL, 1);

    // Главный цикл сервера
    while (1)
    {
        // Ожидание запроса от клиента
        sem_wait(sem_id);

        // Обработка запроса
        if (stolen_goods->items == 0) {
            printf("Сервер: на складе тихо...\n");
        }

        // Освобождение доступа к общим ресурсам
        sem_post(sem_id);
        if (stolen_goods->items != 0)
        {
            printf("Сервер: у нас украли %d предметов со склада...\n", stolen_goods->items);
        }
        // Проверка условия завершения
        if (stolen_goods->items >= rand() % 41 + 10)
        {
            break; // Завершение сервера
        }

        // Задержка перед следующей итерацией
        sleep(1);
    }
    
    printf("Тревога! У нас украли %d товаров со склада с общей стоимостью в %d$!!!", stolen_goods->items, stolen_goods->value);
    // Отключение от разделяемой памяти
    shmdt(stolen_goods);

    // Удаление разделяемой памяти и семафора
    shmctl(shm_id, IPC_RMID, NULL);
    semctl(sem_id, 0, IPC_RMID);

    return 0;
}
```

## Код клиента на языке C:
```c
// Код клиента

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <time.h>

// Ключи для разделяемой памяти и семафора
#define SHM_KEY 1234
#define SEM_KEY 5678

// Структура для хранения похищенного имущества
typedef struct
{
    int items;
    int value;
} StolenGoods;

// Функция для ожидания освобождения семафора
void sem_wait(int sem_id)
{
    struct sembuf sem_op = {0, -1, 0};
    semop(sem_id, &sem_op, 1);
}

// Функция для освобождения семафора
void sem_post(int sem_id)
{
    struct sembuf sem_op = {0, 1, 0};
    semop(sem_id, &sem_op, 1);
}

int main()
{
    // Получение ключа для разделяемой памяти
    int shm_id = shmget(SHM_KEY, sizeof(StolenGoods), 0666);
    if (shm_id == -1)
    {
        perror("Ошибка получения разделяемой памяти");
        exit(EXIT_FAILURE);
    }

    // Получение ключа для семафора
    int sem_id = semget(SEM_KEY, 1, 0666);
    if (sem_id == -1)
    {
        perror("Ошибка получения семафора");
        exit(EXIT_FAILURE);
    }

    // Инициализация генератора случайных чисел
    srand(time(NULL));

    // Подключение к разделяемой памяти
    StolenGoods *stolen_goods = (StolenGoods *)shmat(shm_id, NULL, 0);
    if (stolen_goods == (void *)-1)
    {
        perror("Ошибка отображения разделяемой памяти");
        exit(EXIT_FAILURE);
    }

    // Цикл действий клиента
    while (1)
    {
        // Запрос доступа к общим ресурсам
        sem_wait(sem_id);

        // Выполнение действий
        if (stolen_goods->items == 0) {
            printf("Клиент: выполняет действия...\n");
        }

        // Обновление данных и отправка их серверу
        stolen_goods->items += 1;
        stolen_goods->value += rand() % (10000 - 100 + 1) + 10000;
        
        printf("Клиент: Вор похитил %d предметов, общая стоимость %d\n", stolen_goods->items, stolen_goods->value);

        // Освобождение доступа к общим ресурсам
        sem_post(sem_id);

        // Задержка перед следующей итерацией
        sleep(1);

        // Проверка условия завершения
        if (stolen_goods->items >= rand() % 41 + 10)
        {
            printf("Вор сбежал.");
            break; // Завершение клиента
        }
    }

    // Отключение от разделяемой памяти
    shmdt(stolen_goods);

    return 0;
}

```


## Результаты программы (в прошлой ДЗ):
### Вставил код из прошлого домашнего задания для сравнения.

```
Дочерний процесс с PID 188 похитил товар. Всего похищено: 1
Дочерний процесс с PID 189 похитил товар. Всего похищено: 2
Дочерний процесс с PID 190 похитил товар. Всего похищено: 3
Дочерний процесс с PID 188 похитил товар. Всего похищено: 4
Дочерний процесс с PID 189 похитил товар. Всего похищено: 5
Дочерний процесс с PID 190 похитил товар. Всего похищено: 6
Дочерний процесс с PID 188 похитил товар. Всего похищено: 7
Дочерний процесс с PID 189 похитил товар. Всего похищено: 8
Дочерний процесс с PID 190 похитил товар. Всего похищено: 9
Дочерний процесс с PID 188 похитил товар. Всего похищено: 10
Дочерний процесс с PID 189 похитил товар. Всего похищено: 11
Дочерний процесс с PID 190 похитил товар. Всего похищено: 12
Дочерний процесс с PID 188 похитил товар. Всего похищено: 13
Дочерний процесс с PID 189 похитил товар. Всего похищено: 14
Дочерний процесс с PID 190 похитил товар. Всего похищено: 15
Дочерний процесс с PID 188 похитил товар. Всего похищено: 16
Дочерний процесс с PID 189 похитил товар. Всего похищено: 17
Дочерний процесс с PID 190 похитил товар. Всего похищено: 18
Дочерний процесс с PID 188 похитил товар. Всего похищено: 19
Дочерний процесс с PID 189 похитил товар. Всего похищено: 20
Дочерний процесс с PID 190 похитил товар. Всего похищено: 21
Дочерний процесс с PID 188 похитил товар. Всего похищено: 22
Дочерний процесс с PID 189 похитил товар. Всего похищено: 23
Дочерний процесс с PID 190 похитил товар. Всего похищено: 24
Дочерний процесс с PID 188 похитил товар. Всего похищено: 25
Дочерний процесс с PID 189 похитил товар. Всего похищено: 26
Дочерний процесс с PID 190 похитил товар. Всего похищено: 27
Дочерний процесс с PID 188 похитил товар. Всего похищено: 28
Дочерний процесс с PID 189 похитил товар. Всего похищено: 29
Дочерний процесс с PID 190 похитил товар. Всего похищено: 30
Дочерний процесс с PID 188 завершил работу. Всего похищено: 30, Общая стоимость: 7712
Дочерний процесс с PID 189 завершил работу. Всего похищено: 30, Общая стоимость: 8376
Дочерний процесс с PID 190 завершил работу. Всего похищено: 30, Общая стоимость: 8844
```

## Результат программ (текущий):
### Для удобного отображения покажу скриншот того, что получилось.
![results](https://github.com/DeadRick/OS_Homework3/assets/39325834/4a9d779d-4f9f-4b9e-82aa-60a28017f89d)
Как можно увидеть, к программе можно подключить несколько клиентов. Хотя я и делала изначально с низкой оценкой, но получилось так, что и на оценки повыше мне удалось выполнить программу. При этом, если посмотреть, то вор, который находится справа внизу экрана, подключился под конец кражи имущества со склада. 

### Второй запуск.
![image](https://github.com/DeadRick/OS_Homework3/assets/39325834/59739a74-62fd-4f56-a446-9c0fa7aa6f57)
Тут код был немного изменён. До этого, если склад завершал работу, то клиент получал доступ к общей памяти, тем самым продолжая воровать предметы. Сейчас же код работает так, что сервер указывает на то, что склад не пуст. Клиент ворует до того момента, пока сервера не скажет, что склад пуст, а затем завершит свою работу.

Тем самым, была обновленна структура StolenGoods:
```C
typedef struct
{
    int items;
    int value;
    int isEmpty;
} StolenGoods;
```
Сервер указывает, что склад пуст:
```C
// Код сервера
        if (stolen_goods->items >= rand() % 41 + 10)
        {
            stolen_goods->isEmpty = -1;
            break; // Завершение сервера
        }
```

Клиент же проверяет остались ли предметы на складе:
```c
    // Проверка условия завершения
        if (stolen_goods->isEmpty == -1)
        {
            printf("Клиент: Воровать больше нечего. Склад пуст. Вор сбежал... \n");
            break; // Завершение клиента
        }
```

Весь актуальный код можно найти в папке программы.

![image](https://github.com/DeadRick/OS_Homework3/assets/39325834/a264f1e7-3452-4130-8d2b-e286a674b328)

На этом скриншоте можно увидеть, что клиент отключился и снова подключился. Это никак не сломало программу. Добавил ID для каждого клиента, чтобы было удобнее остледить их работу.
Таким образом, программа была выполена на 8 баллов, ведь клиенты могут подлючаться и отключаться в любой момент (конечно, пока сервер еще существует).

