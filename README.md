# Демьяненко Виктор Николаевич БПИ217
## Домашнее задание по ОС #3
## Вариант 29

## Цель и задачи: 
Изучить работу с транспортным протоколом TCP. Научиться разбивать задачу  на части, для последующего их выполнения серверами и клиентами.

## Условие задачи:

Первая военная задача. Темной–темной ночью прапорщики Иванов, Петров и Нечепорук занимаются хищением военного имущества со склада родной военной части. Будучи умными людьми и
отличниками боевой и строевой подготовки, прапорщики ввели разделение труда. Иванов выносит имущество со склада и передает его
в руки Петрову, который грузит его в грузовик. Нечепорук стоит на
шухере и заодно подсчитывает рыночную стоимость добычи поле
погрузки в грузовик очередной партии похищенного. Требуется
создать приложение, моделирующее деятельность прапорщиков. Время выполнения каждого действия прапорщиков–
процессов задавать случайным образом.

## Выполненное условие:

- 4 балла ✓
- 5 балла ✓
- 6 балла ✓
- 7 балла ✓
- 8 балла ✓
- 9 баллов (смотреть последний скриншот)

## Сценарий задачи:

Для решения данной задачи клиент-серверного взаимодействия между прапорщиками Ивановым, Петровым и Нечепоруком, мы можем использовать схему "один сервер - множество клиентов". Сервер будет отвечать за координацию действий и хранение общих данных, а каждый клиент (прапорщик) будет выполнять свою задачу в отдельном процессе. Также в этот раз изменил я изменил имена прапорщиков на "Вор".

## Схема решения 

1. Сервер запускается и создает необходимые для работы ресурсы, такие как разделяемая память и семафоры.
2. Клиенты (прапорщики) запускаются и подключаются к серверу.
3. Каждый клиент случайным образом определяет время выполнения своих действий, например, время выноса имущества со склада и загрузки его в грузовик.
4. Клиенты отправляют запросы серверу для получения доступа к общим ресурсам (например, семафорам) перед выполнением своих действий.
5. Сервер обрабатывает запросы клиентов и контролирует доступ к общим ресурсам, чтобы обеспечить взаимоисключение и согласованность операций.
6. Клиенты выполняют свои действия (выносят имущество со склада, загружают его в грузовик) и отправляют обновленные данные серверуx`.
7. Сервер получает обновленные данные от клиентов и может выполнять дополнительную обработку, например, подсчет рыночной стоимости добычи.
8. Процесс повторяется до достижения заданного условия завершения (например, заданное количество циклов выполнения действий).

Каждый процесс клиента (прапорщика) будет выполнять следующие шаги:

1. Подключение к серверу.
2. Генерация случайного времени выполнения действий.
3. Цикл действий, включающий:
- Ожидание разрешения доступа к общим ресурсам, отправка запроса серверу.
- Выполнение действий (вынос имущества, загрузка в грузовик).
- Обновление данных и отправка их серверу.
- Ожидание разрешения доступа к общим ресурсам после выполнения действий.
4. Отключение от сервера и завершение процесса клиента.

## Завершение программы и удаление ресурсов

- Программа будет завершаться, когда все процессы прапорщиков успешно выполнят свои действия или при прерывании с клавиатуры по соответствующему сигналу (например, Ctrl+C). При завершении программы будет предусмотрено корректное удаление разделяемой памяти и семафоров.
- Разделяемая память и семафоры будут корректно удалены при завершении программы или при обработке сигнала прерывания с клавиатуры. Это будет выполнено с использованием функций удаления разделяемой памяти и семафоров.


## Код сервера на языке С:

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <pthread.h>

#define PORT 8080

typedef struct
{
    int items;
    int value;
} StolenGoods;

typedef struct
{
    int socket;
    int isObserver;
} ClientInfo;

StolenGoods stolenGoods; // Объявление структуры StolenGoods
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // Инициализация мьютекса
int observerSocket = -1; // Сокет наблюдателя
pthread_mutex_t observerMutex = PTHREAD_MUTEX_INITIALIZER; // Мьютекс для доступа к сокету наблюдателя

void *clientHandler(void *arg)
{
    ClientInfo client = *(ClientInfo *)arg;
    char buffer[1024];

    // Отправка разрешения доступа к общим ресурсам
    send(client.socket, "Access granted", strlen("Access granted"), 0);

    // Если клиент - наблюдатель, сохраняем его сокет
    if (client.isObserver)
    {
        pthread_mutex_lock(&observerMutex);
        observerSocket = client.socket;
        printf("Сервер: наблюдатель подключен\n");

        // Отправляем начальную стоимость склада
        char valueStr[20];
        snprintf(valueStr, sizeof(valueStr), "%d", stolenGoods.value);
        send(observerSocket, valueStr, strlen(valueStr), 0);
        pthread_mutex_unlock(&observerMutex);
    }

    // Главный цикл обработки клиента
    while (1)
    {
        // Получение данных от клиента
        int bytesReceived = recv(client.socket, buffer, 1024, 0);
        if (bytesReceived <= 0)
        {
            // Проблема при получении данных или соединение закрыто
            break;
        }
        buffer[bytesReceived] = '\0';

        // Проверка условия завершения
        if (stolenGoods.items <= 0 || stolenGoods.value <= 0)
        {
            printf("Сервер: все предметы похищены\n");
            break;
        }

        // Обновление структуры с похищенным имуществом
        int price = rand() % 41 + 10;
        pthread_mutex_lock(&mutex);
        stolenGoods.items--;
        stolenGoods.value -= price;

        printf("Сервер: со склада похитили товар стоимостью в %d$.\n", price);

        // Преобразование стоимости в строку
        char valueStr[20];
        snprintf(valueStr, sizeof(valueStr), "%d", stolenGoods.value);

        // Отправка стоимости клиенту
        send(client.socket, valueStr, strlen(valueStr), 0);

        // Отправка стоимости наблюдателю
        if (client.isObserver)
        {
            pthread_mutex_lock(&observerMutex);
            if (observerSocket != -1)
            {
                send(observerSocket, valueStr, strlen(valueStr), 0);
            }
            pthread_mutex_unlock(&observerMutex);
        }

        pthread_mutex_unlock(&mutex);

        // Задержка перед следующей итерацией
        sleep(1);
    }

    // Закрытие сокета клиента
    close(client.socket);
    pthread_exit(NULL);
}

int main()
{
    int serverSocket, newSocket;
    struct sockaddr_in serverAddr, clientAddr;
    socklen_t addrLen = sizeof(clientAddr);
    char buffer[1024];
    pthread_t threadId;

    // Создание сокета
    if ((serverSocket = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror("Ошибка создания сокета");
        exit(EXIT_FAILURE);
    }

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(PORT);

    // Привязка сокета к указанному порту
    if (bind(serverSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
    {
        perror("Ошибка привязки сокета");
        exit(EXIT_FAILURE);
    }

    // Ожидание подключения клиентов
    if (listen(serverSocket, 5) < 0)
    {
        perror("Ошибка ожидания подключений");
        exit(EXIT_FAILURE);
    }

    printf("Сервер: ожидание подключений...\n");

    // Инициализация структуры с похищенным имуществом
    stolenGoods.items = 100;  // Начальное количество предметов
    stolenGoods.value = 1000; // Начальная стоимость

    // Главный цикл сервера
    while (1)
    {
        // Принятие нового подключения от клиента
        if ((newSocket = accept(serverSocket, (struct sockaddr *)&clientAddr, &addrLen)) < 0)
        {
            perror("Ошибка при принятии подключения");
            exit(EXIT_FAILURE);
        }

        printf("Сервер: новое подключение принято\n");

        // Создание потока для обработки клиента
        ClientInfo client;
        client.socket = newSocket;

        // Проверка, является ли клиент наблюдателем
        
        if (strstr(buffer, "2") != NULL)
        {
            client.isObserver = 1;
        }
        else
        {
            client.isObserver = 0;
        }

        if (pthread_create(&threadId, NULL, clientHandler, (void *)&client) != 0)
        {
            perror("Ошибка при создании потока");
            exit(EXIT_FAILURE);
        }

        // Освобождение ресурсов потока
        pthread_detach(threadId);

        // Проверка условия завершения
        if (stolenGoods.items <= 0 || stolenGoods.value <= 0)
        {
            close(serverSocket);
            break;
        }
    }

    // Закрытие сокета сервера
    close(serverSocket);

    return 0;
}

```

## Код клиента на языке C:
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <arpa/inet.h>


#define PORT 8080

typedef struct {
    int items;
    int value;
} StolenGoods;

int main() {
    int clientSocket;
    struct sockaddr_in serverAddr;
    char buffer[1024];

    // Создание сокета
    if ((clientSocket = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Ошибка создания сокета");
        exit(EXIT_FAILURE);
    }

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT);

    // Преобразование IP-адреса из текстового вида в бинарный
    if (inet_pton(AF_INET, "127.0.0.1", &(serverAddr.sin_addr)) <= 0) {
        perror("Ошибка преобразования IP-адреса");
        exit(EXIT_FAILURE);
    }

    // Подключение к серверу
    if (connect(clientSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0) {
        perror("Ошибка подключения");
        exit(EXIT_FAILURE);
    }

    // Ожидание разрешения доступа к общим ресурсам от сервера
    memset(buffer, 0, sizeof(buffer));
    recv(clientSocket, buffer, 1024, 0);
    printf("Клиент: разрешение доступа получено: %s\n", buffer);

    // Главный цикл клиента
    while (1) {
        // Отправка данных на сервер
        send(clientSocket, "Data from client", strlen("Data from client"), 0);

        // Получение данных от сервера
        memset(buffer, 0, sizeof(buffer));
        int bytesGet = recv(clientSocket, buffer, 1024, 0);
        
        if (bytesGet == 0) {
            printf("На складе украли всё, что можно.\n");
            break;
        }

        printf("Клиент: вор украл со склада %s$\n", buffer);

        // Проверка условия завершения
        if (strcmp(buffer, "Сервер: все предметы похищены") == 0) {
            printf("Клиент: все предметы похищены, завершение работы\n");
            break;
        }

        // Задержка перед следующей итерацией
        sleep(1);
    }
    
    printf
    // Закрытие сокета клиента
    close(clientSocket);

    return 0;
}
```

## Код наблюдателя на языке C
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main()
{
    int socketId;
    struct sockaddr_in serverAddr;
    char buffer[BUFFER_SIZE];

    // Создание сокета
    if ((socketId = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        perror("Ошибка создания сокета");
        exit(EXIT_FAILURE);
    }

    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT);

    // Преобразование IP-адреса из текстового в бинарный формат
    if (inet_pton(AF_INET, "127.0.0.1", &(serverAddr.sin_addr)) <= 0)
    {
        perror("Ошибка преобразования адреса");
        exit(EXIT_FAILURE);
    }

    // Подключение к серверу
    if (connect(socketId, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0)
    {
        perror("Ошибка подключения");
        exit(EXIT_FAILURE);
    }

    // Отправка типа клиента (наблюдатель)
    int clientType = 2;
    send(socketId, &clientType, sizeof(clientType), 0);

    printf("Наблюдатель: успешно подключен\n");

    // Цикл получения информации от сервера
    while (1)
    {
        // Получение стоимости склада от сервера
        int receivedBytes = recv(socketId, buffer, BUFFER_SIZE, 0);
        if (receivedBytes <= 0)
            break;

        // Преобразование стоимости в число
        int warehouseValue;
        sscanf(buffer, "%d", &warehouseValue);

        // Вывод информации о стоимости склада
        printf("Наблюдатель: текущая стоимость склада: %d$\n", warehouseValue);
    }

    // Закрытие сокета
    close(socketId);

    return 0;
}

```

## Результаты программы (в прошлой ДЗ):
### Вставил код из прошлого домашнего задания для сравнения.

```
Дочерний процесс с PID 188 похитил товар. Всего похищено: 1
Дочерний процесс с PID 189 похитил товар. Всего похищено: 2
Дочерний процесс с PID 190 похитил товар. Всего похищено: 3
Дочерний процесс с PID 188 похитил товар. Всего похищено: 4
Дочерний процесс с PID 189 похитил товар. Всего похищено: 5
Дочерний процесс с PID 190 похитил товар. Всего похищено: 6
Дочерний процесс с PID 188 похитил товар. Всего похищено: 7
Дочерний процесс с PID 189 похитил товар. Всего похищено: 8
Дочерний процесс с PID 190 похитил товар. Всего похищено: 9
Дочерний процесс с PID 188 похитил товар. Всего похищено: 10
Дочерний процесс с PID 189 похитил товар. Всего похищено: 11
Дочерний процесс с PID 190 похитил товар. Всего похищено: 12
Дочерний процесс с PID 188 похитил товар. Всего похищено: 13
Дочерний процесс с PID 189 похитил товар. Всего похищено: 14
Дочерний процесс с PID 190 похитил товар. Всего похищено: 15
Дочерний процесс с PID 188 похитил товар. Всего похищено: 16
Дочерний процесс с PID 189 похитил товар. Всего похищено: 17
Дочерний процесс с PID 190 похитил товар. Всего похищено: 18
Дочерний процесс с PID 188 похитил товар. Всего похищено: 19
Дочерний процесс с PID 189 похитил товар. Всего похищено: 20
Дочерний процесс с PID 190 похитил товар. Всего похищено: 21
Дочерний процесс с PID 188 похитил товар. Всего похищено: 22
Дочерний процесс с PID 189 похитил товар. Всего похищено: 23
Дочерний процесс с PID 190 похитил товар. Всего похищено: 24
Дочерний процесс с PID 188 похитил товар. Всего похищено: 25
Дочерний процесс с PID 189 похитил товар. Всего похищено: 26
Дочерний процесс с PID 190 похитил товар. Всего похищено: 27
Дочерний процесс с PID 188 похитил товар. Всего похищено: 28
Дочерний процесс с PID 189 похитил товар. Всего похищено: 29
Дочерний процесс с PID 190 похитил товар. Всего похищено: 30
Дочерний процесс с PID 188 завершил работу. Всего похищено: 30, Общая стоимость: 7712
Дочерний процесс с PID 189 завершил работу. Всего похищено: 30, Общая стоимость: 8376
Дочерний процесс с PID 190 завершил работу. Всего похищено: 30, Общая стоимость: 8844
```

## Результат программ (текущий):
### Для удобного отображения покажу скриншот того, что получилось.
![image](https://github.com/DeadRick/OS_Homework3/assets/39325834/84316eaa-4d9f-4fcf-8cf9-8c51dd3a5afc)
Как можно увидеть, к программе можно подключить клиента и наблюдателя. Хотя я и делала изначально с низкой оценкой, но получилось так, что и на оценки повыше мне удалось выполнить программу.  

### Второй запуск.
![image](https://github.com/DeadRick/OS_Homework3/assets/39325834/cc2e8b18-407d-4fc7-8009-4a767dfe7a8d)
При этом, можно подключать несколько клиентов, которые одновременно будут красть вещи со склада.

Весь актуальный код можно найти в папке программы.

![image](https://github.com/DeadRick/OS_Homework3/assets/39325834/a264f1e7-3452-4130-8d2b-e286a674b328)

На этом скриншоте можно увидеть, что клиент отключился и снова подключился. Это никак не сломало программу. Добавил ID для каждого клиента, чтобы было удобнее остледить их работу.
Таким образом, программа была выполена на 8 баллов, ведь клиенты могут подлючаться и отключаться в любой момент (конечно, пока сервер еще существует).
![image](https://github.com/DeadRick/OS_Homework3/assets/39325834/9395370c-8fa5-4c3d-9c73-253820a2d8c8)
Вот демонстрация того, что клиенты могут отключаться и снова подключаться, при этом, продолжая делать все свои дела.
